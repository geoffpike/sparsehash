<HTML>

<HEAD>
<title>Performance notes: sparse_hash, dense_hash, sparsetable</title>
</HEAD>

<BODY>

<H2>Performance Numbers</H2>

<p>Here are some performance numbers from an example desktop machine,
taken from a version of time_hash_map that was instrumented to also
report memory allocation information (this modification is not
included by default because it required a big hack to do, including
modifying the STL code to not try to do its own freelist management).</p>

<p>Note there are lots of caveats on these numbers: they may differ from
machine to machine and compiler to compiler, and they only test a very
particular usage pattern that may not match how you use hashtables --
for instance, they test hashtables with very small keys.  However,
they're still useful for a baseline comparison of the various
hashtable implementations.</p>

<p>These figures are from a 2.80GHz Pentium 4 with 2G of memory.  The
'standard' hash_map and map implementations are the SGI STL code
included with <tt>gcc2</tt>.  Compiled with <tt>gcc2.95.3 -g
-O2</tt></p>

<pre>
======
Average over 10000000 iterations
Wed Dec  8 14:56:38 PST 2004

SPARSE_HASH_MAP:
map_grow                  665 ns
map_predict/grow          303 ns
map_replace               177 ns
map_fetch                 117 ns
map_remove                192 ns
memory used in map_grow    84.3956 Mbytes

DENSE_HASH_MAP:
map_grow                   84 ns
map_predict/grow           22 ns
map_replace                18 ns
map_fetch                  13 ns
map_remove                 23 ns
memory used in map_grow   256.0000 Mbytes

STANDARD HASH_MAP:
map_grow                  162 ns
map_predict/grow          107 ns
map_replace                44 ns
map_fetch                  22 ns
map_remove                124 ns
memory used in map_grow   204.1643 Mbytes

STANDARD MAP:
map_grow                  297 ns
map_predict/grow          282 ns
map_replace               113 ns
map_fetch                 113 ns
map_remove                238 ns
memory used in map_grow   236.8081 Mbytes
</pre>
  
<p>These figures are from a Intel Core i7-4790K with 16G of memory. 
  Compiled on Ubuntu 14.04 with <tt>gcc4.8.5 -O3</tt>
</p>

<pre>
Average over 200000000 iterations
Current time (GMT): Wed May 17 13:57:50 2017

*** WARNING ***: sys/resources.h was not found, so all times
                 reported are wall-clock time, not user time

SPARSE_HASH_MAP (4 byte objects, 200000000 iterations):
map_grow               76.4 ns  (414748356 hashes, 814748425 copies)
map_predict/grow       40.8 ns  (200000000 hashes, 600000000 copies)
map_replace            20.3 ns  (200000000 hashes,        0 copies)
map_fetch_random      197.3 ns  (200000000 hashes,        0 copies)
map_fetch_sequential   37.1 ns  (200000000 hashes,        0 copies)
map_fetch_empty        13.1 ns  (       0 hashes,        0 copies)
map_remove             42.2 ns  (200000000 hashes, 200000000 copies)
map_toggle            103.2 ns  (407999999 hashes, 831999996 copies)
map_iterate             2.3 ns  (       0 hashes,        0 copies)
memory used in map_grow    1.7 GB

stresshashfunction map_size=256 stride=1: 147.2ns/insertion
stresshashfunction map_size=256 stride=256: 99.1ns/insertion
stresshashfunction map_size=1024 stride=1: 263.9ns/insertion
stresshashfunction map_size=1024 stride=1024: 247.4ns/insertion

DENSE_HASH_MAP (4 byte objects, 200000000 iterations):
map_grow               33.4 ns  (468435464 hashes, 1542177392 copies)
map_predict/grow        8.5 ns  (200000000 hashes, 200000000 copies)
map_replace             4.0 ns  (200000000 hashes,        0 copies)
map_fetch_random       23.9 ns  (200000000 hashes,        0 copies)
map_fetch_sequential    4.1 ns  (200000000 hashes,        0 copies)
map_fetch_empty         3.3 ns  (       0 hashes,        0 copies)
map_remove              7.3 ns  (200000000 hashes, 200000000 copies)
map_toggle             26.6 ns  (412499999 hashes, 899999960 copies)
map_iterate             2.0 ns  (       0 hashes,        0 copies)
memory used in map_grow    6.2 GB

stresshashfunction map_size=256 stride=1: 16.5ns/insertion
stresshashfunction map_size=256 stride=256: 7.2ns/insertion
stresshashfunction map_size=1024 stride=1: 25.3ns/insertion
stresshashfunction map_size=1024 stride=1024: 16.1ns/insertion

STANDARD HASH_MAP (4 byte objects, 200000000 iterations):
map_grow               53.2 ns  (200000000 hashes, 200000000 copies)
map_predict/grow       31.1 ns  (200000000 hashes, 200000000 copies)
map_replace             8.5 ns  (200000000 hashes,        0 copies)
map_fetch_random       92.3 ns  (200000000 hashes,        0 copies)
map_fetch_sequential    7.8 ns  (200000000 hashes,        0 copies)
map_fetch_empty         6.4 ns  (200000000 hashes,        0 copies)
map_remove             20.7 ns  (200000000 hashes,        0 copies)
map_toggle             36.8 ns  (400000000 hashes, 200000000 copies)
map_iterate             2.4 ns  (       0 hashes,        0 copies)
memory used in map_grow    8.0 GB

stresshashfunction map_size=256 stride=1: 24.4ns/insertion
stresshashfunction map_size=256 stride=256: 24.5ns/insertion
stresshashfunction map_size=1024 stride=1: 24.5ns/insertion
stresshashfunction map_size=1024 stride=1024: 24.5ns/insertion
</pre>


<H2><A name="hashfn">A Note on Hash Functions</A></H2>

<p>For good performance, the sparsehash hash routines depend on a good
hash function: one that distributes data evenly.  Many hashtable
implementations come with sub-optimal hash functions that can degrade
performance.  For instance, the hash function given in Knuth's _Art of
Computer Programming_, and the default string hash function in SGI's
STL implementation, both distribute certain data sets unevenly,
leading to poor performance.</p>

<p>As an example, in one test of the default SGI STL string hash
function against the Hsieh hash function (see below), for a particular
set of string keys, the Hsieh function resulted in hashtable lookups
that were 20 times as fast as the STLPort hash function.  The string
keys were chosen to be "hard" to hash well, so these results may not
be typical, but they are suggestive.</p>

<p>There has been much research over the years into good hash
functions.  Here are some hash functions of note.</p>

<ul>
  <li> Bob Jenkins: <A HREF="http://burtleburtle.net/bob/hash/">http://burtleburtle.net/bob/hash/</A>
  <li> Paul Hsieh: <A HREF="http://www.azillionmonkeys.com/qed/hash.html">http://www.azillionmonkeys.com/qed/hash.html</A>
  <li> Fowler/Noll/Vo (FNV): <A HREF="http://www.isthe.com/chongo/tech/comp/fnv/">http://www.isthe.com/chongo/tech/comp/fnv/</A>
  <li> MurmurHash: <A HREF="http://murmurhash.googlepages.com/">http://murmurhash.googlepages.com/</A>
</ul>

</body>
</html>
